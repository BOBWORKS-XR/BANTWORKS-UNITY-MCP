/**
 * Write WebRoot JavaScript
 *
 * Write JavaScript files to the WebRoot folder for built Banter scenes.
 */

import * as fs from "fs";
import * as path from "path";
import type { BanterMCPConfig } from "../lib/config.js";

export interface WriteWebRootResult {
  success: boolean;
  filePath?: string;
  error?: string;
  message?: string;
}

/**
 * Write JavaScript code to the WebRoot folder
 */
export async function writeWebRootJS(
  code: string,
  filename: string,
  config: BanterMCPConfig
): Promise<WriteWebRootResult> {
  if (!config.unityProjectPath) {
    return {
      success: false,
      error: "UNITY_PROJECT_PATH not set. Cannot write to Unity project.",
    };
  }

  try {
    // Ensure WebRoot folder exists
    if (!fs.existsSync(config.webRootPath)) {
      fs.mkdirSync(config.webRootPath, { recursive: true });
    }

    // Validate filename
    if (!filename.endsWith(".js") && !filename.endsWith(".html")) {
      filename = `${filename}.js`;
    }

    // Basic JavaScript validation
    const validation = validateJavaScript(code);
    if (!validation.valid) {
      return {
        success: false,
        error: `JavaScript validation failed: ${validation.errors.join(", ")}`,
      };
    }

    // Add helpful header comment if not present
    let finalCode = code;
    if (!code.trimStart().startsWith("//") && !code.trimStart().startsWith("/*")) {
      finalCode = `// Banter WebRoot JavaScript
// Generated by Banter MCP
// This runs at runtime in built Banter scenes

${code}`;
    }

    // Write the file
    const filePath = path.join(config.webRootPath, filename);
    fs.writeFileSync(filePath, finalCode, "utf-8");

    const relativePath = path.relative(config.unityProjectPath, filePath);

    return {
      success: true,
      filePath: relativePath,
      message: `JavaScript written to ${relativePath}`,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error writing JavaScript",
    };
  }
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Basic JavaScript validation
 */
function validateJavaScript(code: string): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check for obvious syntax issues
  const openBraces = (code.match(/{/g) || []).length;
  const closeBraces = (code.match(/}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Mismatched braces: ${openBraces} open, ${closeBraces} close`);
  }

  const openParens = (code.match(/\(/g) || []).length;
  const closeParens = (code.match(/\)/g) || []).length;
  if (openParens !== closeParens) {
    errors.push(`Mismatched parentheses: ${openParens} open, ${closeParens} close`);
  }

  const openBrackets = (code.match(/\[/g) || []).length;
  const closeBrackets = (code.match(/\]/g) || []).length;
  if (openBrackets !== closeBrackets) {
    errors.push(`Mismatched brackets: ${openBrackets} open, ${closeBrackets} close`);
  }

  // Check for Banter-specific patterns
  if (!code.includes("BS.") && !code.includes("BanterScene")) {
    warnings.push("No Banter API usage detected (BS.*). Is this intentional?");
  }

  // Check for common mistakes
  if (code.includes("document.") || code.includes("window.")) {
    warnings.push("DOM APIs (document/window) may have limited availability in Banter context");
  }

  if (code.includes("require(") || code.includes("import ")) {
    warnings.push("Module imports may not work in Banter runtime context");
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}
